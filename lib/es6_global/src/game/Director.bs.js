// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE

import * as List from "./../../../../node_modules/bs-platform/lib/es6/list.js";
import * as Actor from "./Actor.bs.js";
import * as Block from "./../../../../node_modules/bs-platform/lib/es6/block.js";
import * as Utils from "./Utils.bs.js";
import * as Random from "./../../../../node_modules/bs-platform/lib/es6/random.js";
import * as Caml_int32 from "./../../../../node_modules/bs-platform/lib/es6/caml_int32.js";

function handleKey(key_code, c_direction) {
  var switcher = key_code - 37 | 0;
  if (switcher > 3 || switcher < 0) {
    return undefined;
  } else {
    switch (switcher) {
      case 0 : 
          if (c_direction !== /* Left */3 && c_direction !== /* Right */1) {
            return /* Left */3;
          } else {
            return undefined;
          }
      case 1 : 
          if (c_direction !== /* Up */0 && c_direction !== /* Down */2) {
            return /* Up */0;
          } else {
            return undefined;
          }
      case 2 : 
          if (c_direction !== /* Right */1 && c_direction !== /* Left */3) {
            return /* Right */1;
          } else {
            return undefined;
          }
      case 3 : 
          if (c_direction !== /* Down */2 && c_direction !== /* Up */0) {
            return /* Down */2;
          } else {
            return undefined;
          }
      
    }
  }
}

function spawnRandom(param, param$1, seed) {
  Random.init(seed);
  return /* tuple */[
          Random.$$int(param[1]) + param[0] | 0,
          Random.$$int(param$1[1]) + param$1[0] | 0
        ];
}

function spawnRandomSuper(param, param$1, seed) {
  Random.init(seed);
  return /* tuple */[
          Random.$$int(param[1]) + param[0] | 0,
          Random.$$int(param$1[1]) + param$1[0] | 0,
          List.nth(/* :: */[
                "x",
                /* :: */[
                  "o",
                  /* :: */[
                    ">",
                    /* [] */0
                  ]
                ]
              ], Random.$$int(3))
        ];
}

function getHeadTile(snake, tileSize) {
  var match = List.hd(Actor.Snake[/* getData */7](snake));
  var match$1 = match[0];
  return /* tuple */[
          Caml_int32.div(match$1[0], tileSize),
          Caml_int32.div(match$1[1], tileSize)
        ];
}

function checkGridCollision(snake, grid, tileSize) {
  var match = List.hd(Actor.Snake[/* getData */7](snake));
  var x = match[0][0];
  var headTile = getHeadTile(snake, tileSize);
  var tile = Utils.MyList[/* find_opt */4]((function (param) {
          var match = param[0];
          if (match[0] === headTile[0]) {
            return match[1] === headTile[1];
          } else {
            return false;
          }
        }), grid);
  if (tile !== undefined) {
    var match$1 = tile;
    var x$prime = match$1[0][0];
    switch (match$1[1]) {
      case 0 : 
          return false;
      case 1 : 
          return true;
      case 2 : 
          return x <= (Caml_int32.imul(x$prime, tileSize) + (tileSize / 2 | 0) | 0);
      case 3 : 
          return x >= (Caml_int32.imul(x$prime, tileSize) + (tileSize / 2 | 0) | 0);
      
    }
  } else {
    return false;
  }
}

function updateGame(t, oldGame, mutableState, constants) {
  var tileSize = constants[/* tileSize */4];
  var direction = mutableState[/* direction */0];
  var level = mutableState[/* level */3];
  var winCondition = level[/* winCondition */1];
  var grid = level[/* grid */0];
  var getAllowedSpawningPositions = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        var match$1 = match[0];
        var gridY = match$1[1];
        var gridX = match$1[0];
        switch (match[1]) {
          case 0 : 
              var x = Caml_int32.imul(gridX, tileSize);
              var y = Caml_int32.imul(gridY, tileSize);
              return /* :: */[
                      /* tuple */[
                        x,
                        y + (tileSize / 2 | 0) | 0
                      ],
                      /* :: */[
                        /* tuple */[
                          x + (tileSize / 2 | 0) | 0,
                          y
                        ],
                        /* :: */[
                          /* tuple */[
                            x + (tileSize / 2 | 0) | 0,
                            y + (tileSize / 2 | 0) | 0
                          ],
                          /* :: */[
                            /* tuple */[
                              x + (tileSize / 2 | 0) | 0,
                              y + tileSize | 0
                            ],
                            /* :: */[
                              /* tuple */[
                                x + tileSize | 0,
                                y + (tileSize / 2 | 0) | 0
                              ],
                              getAllowedSpawningPositions(param[1])
                            ]
                          ]
                        ]
                      ]
                    ];
          case 1 : 
              _param = param[1];
              continue ;
          case 2 : 
              var x$1 = Caml_int32.imul(gridX, tileSize);
              var y$1 = Caml_int32.imul(gridY, tileSize);
              return /* :: */[
                      /* tuple */[
                        x$1 + (tileSize / 2 | 0) | 0,
                        y$1
                      ],
                      /* :: */[
                        /* tuple */[
                          x$1 + (tileSize / 2 | 0) | 0,
                          y$1 + (tileSize / 2 | 0) | 0
                        ],
                        /* :: */[
                          /* tuple */[
                            x$1 + (tileSize / 2 | 0) | 0,
                            y$1 + tileSize | 0
                          ],
                          /* :: */[
                            /* tuple */[
                              x$1 + tileSize | 0,
                              y$1 + (tileSize / 2 | 0) | 0
                            ],
                            getAllowedSpawningPositions(param[1])
                          ]
                        ]
                      ]
                    ];
          case 3 : 
              var x$2 = Caml_int32.imul(gridX, tileSize);
              var y$2 = Caml_int32.imul(gridY, tileSize);
              return /* :: */[
                      /* tuple */[
                        x$2 + (tileSize / 2 | 0) | 0,
                        y$2
                      ],
                      /* :: */[
                        /* tuple */[
                          x$2 + (tileSize / 2 | 0) | 0,
                          y$2
                        ],
                        /* :: */[
                          /* tuple */[
                            x$2 + (tileSize / 2 | 0) | 0,
                            y$2 + (tileSize / 2 | 0) | 0
                          ],
                          /* :: */[
                            /* tuple */[
                              x$2 + (tileSize / 2 | 0) | 0,
                              y$2 + tileSize | 0
                            ],
                            getAllowedSpawningPositions(param[1])
                          ]
                        ]
                      ]
                    ];
          
        }
      } else {
        return /* [] */0;
      }
    };
  };
  var spawnPrey = function (seed) {
    Random.init(seed);
    var allowedPositions = getAllowedSpawningPositions(grid);
    var r = List.nth(allowedPositions, Random.$$int(List.length(getAllowedSpawningPositions(grid))));
    console.log(r);
    return r;
  };
  var getNormalEaten = function (eaten) {
    return List.length(List.filter((function (x) {
                        if (typeof x === "number" || x.tag) {
                          return false;
                        } else {
                          return true;
                        }
                      }))(eaten));
  };
  var spawn = oldGame[/* spawn */3];
  var snake = oldGame[/* snake */2];
  var eaten = oldGame[/* eaten */1];
  var updatedSnake = Actor.Snake[/* move */2](snake, direction, constants[/* memberLength */2], /* tuple */[
        constants[/* windowWidth */1],
        constants[/* windowHeight */0]
      ]);
  var match;
  if (typeof spawn === "number") {
    var match$1 = spawnPrey(t | 0);
    var y = match$1[1];
    var x = match$1[0];
    var normalEaten = getNormalEaten(eaten);
    var match$2 = normalEaten > 0 && normalEaten % 10 === 0;
    match = match$2 ? /* tuple */[
        /* Special */Block.__(1, [/* record */[
              /* pos : tuple */[
                x,
                y
              ],
              /* symbol */"+"
            ]]),
        /* None */0
      ] : /* tuple */[
        /* Normal */Block.__(0, [/* record */[
              /* pos : tuple */[
                x,
                y
              ],
              /* symbol */"*"
            ]]),
        /* None */0
      ];
  } else {
    var match$3 = Actor.Snake[/* checkCollision */5](updatedSnake, spawn[0][/* pos */0], constants[/* memberWidth */3]);
    match = match$3 ? /* tuple */[
        /* None */0,
        spawn
      ] : /* tuple */[
        spawn,
        /* None */0
      ];
  }
  var collided = match[1];
  var newSnake = typeof collided === "number" ? updatedSnake : Actor.Snake[/* eat */3](updatedSnake);
  var gridCollision = checkGridCollision(snake, grid, tileSize);
  var hasWon;
  switch (winCondition.tag | 0) {
    case 1 : 
        hasWon = List.length(eaten) >= winCondition[0];
        break;
    case 0 : 
    case 2 : 
        hasWon = false;
        break;
    
  }
  var tmp;
  if (gridCollision) {
    tmp = /* Lost */2;
  } else if (hasWon) {
    tmp = /* Won */1;
  } else {
    var match$4 = Actor.Snake[/* checkSelfCollision */6](updatedSnake);
    tmp = match$4 ? /* Lost */2 : /* Going */0;
  }
  return /* record */[
          /* state */tmp,
          /* eaten */typeof collided === "number" ? eaten : /* :: */[
              collided,
              eaten
            ],
          /* snake */newSnake,
          /* spawn */match[0]
        ];
}

export {
  handleKey ,
  spawnRandom ,
  spawnRandomSuper ,
  getHeadTile ,
  checkGridCollision ,
  updateGame ,
  
}
/* No side effect */

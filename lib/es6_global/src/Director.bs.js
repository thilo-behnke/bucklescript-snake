// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE

import * as List from "./../../../node_modules/bs-platform/lib/es6/list.js";
import * as Actor from "./Actor.bs.js";
import * as Block from "./../../../node_modules/bs-platform/lib/es6/block.js";
import * as Random from "./../../../node_modules/bs-platform/lib/es6/random.js";

function handleKey(key_code, c_direction) {
  var switcher = key_code - 37 | 0;
  if (switcher > 3 || switcher < 0) {
    return undefined;
  } else {
    switch (switcher) {
      case 0 : 
          if (c_direction !== /* Left */3 && c_direction !== /* Right */1) {
            return /* Left */3;
          } else {
            return undefined;
          }
      case 1 : 
          if (c_direction !== /* Up */0 && c_direction !== /* Down */2) {
            return /* Up */0;
          } else {
            return undefined;
          }
      case 2 : 
          if (c_direction !== /* Right */1 && c_direction !== /* Left */3) {
            return /* Right */1;
          } else {
            return undefined;
          }
      case 3 : 
          if (c_direction !== /* Down */2 && c_direction !== /* Up */0) {
            return /* Down */2;
          } else {
            return undefined;
          }
      
    }
  }
}

function spawnRandom(param, param$1, seed) {
  Random.init(seed);
  return /* tuple */[
          Random.$$int(param[1]) + param[0] | 0,
          Random.$$int(param$1[1]) + param$1[0] | 0
        ];
}

function spawnRandomSuper(param, param$1, seed) {
  Random.init(seed);
  return /* tuple */[
          Random.$$int(param[1]) + param[0] | 0,
          Random.$$int(param$1[1]) + param$1[0] | 0,
          List.nth(/* :: */[
                "x",
                /* :: */[
                  "o",
                  /* :: */[
                    ">",
                    /* [] */0
                  ]
                ]
              ], Random.$$int(3))
        ];
}

function updateGame(t, oldGame, direction, constants) {
  var memberWidth = constants[/* memberWidth */3];
  var windowWidth = constants[/* windowWidth */1];
  var windowHeight = constants[/* windowHeight */0];
  var spawnPrey = function (seed) {
    return spawnRandom(/* tuple */[
                (memberWidth << 2),
                windowWidth - (memberWidth << 2) | 0
              ], /* tuple */[
                (memberWidth << 2),
                windowHeight - (memberWidth << 2) | 0
              ], seed);
  };
  var getNormalEaten = function (eaten) {
    return List.length(List.filter((function (x) {
                        if (typeof x === "number" || x.tag) {
                          return false;
                        } else {
                          return true;
                        }
                      }))(eaten));
  };
  var spawn = oldGame[/* spawn */3];
  var eaten = oldGame[/* eaten */1];
  var updatedSnake = Actor.Snake[/* move */2](oldGame[/* snake */2], direction, constants[/* memberLength */2], /* tuple */[
        windowWidth,
        windowHeight
      ]);
  var match;
  if (typeof spawn === "number") {
    var match$1 = spawnPrey(t | 0);
    var y = match$1[1];
    var x = match$1[0];
    var normalEaten = getNormalEaten(eaten);
    var match$2 = normalEaten > 0 && normalEaten % 10 === 0;
    match = match$2 ? /* tuple */[
        /* Special */Block.__(1, [/* record */[
              /* pos : tuple */[
                x,
                y
              ],
              /* symbol */"+"
            ]]),
        /* None */0
      ] : /* tuple */[
        /* Normal */Block.__(0, [/* record */[
              /* pos : tuple */[
                x,
                y
              ],
              /* symbol */"*"
            ]]),
        /* None */0
      ];
  } else {
    var match$3 = Actor.Snake[/* checkCollision */5](updatedSnake, spawn[0][/* pos */0], memberWidth);
    match = match$3 ? /* tuple */[
        /* None */0,
        spawn
      ] : /* tuple */[
        spawn,
        /* None */0
      ];
  }
  var collided = match[1];
  var newSnake = typeof collided === "number" ? updatedSnake : Actor.Snake[/* eat */3](updatedSnake);
  var match$4 = Actor.Snake[/* checkSelfCollision */6](updatedSnake);
  return /* record */[
          /* state */match$4 ? /* Lost */1 : /* Going */0,
          /* eaten */typeof collided === "number" ? eaten : /* :: */[
              collided,
              eaten
            ],
          /* snake */newSnake,
          /* spawn */match[0]
        ];
}

export {
  handleKey ,
  spawnRandom ,
  spawnRandomSuper ,
  updateGame ,
  
}
/* No side effect */

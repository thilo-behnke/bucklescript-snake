// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE

import * as List from "./../../../node_modules/bs-platform/lib/es6/list.js";
import * as Random from "./../../../node_modules/bs-platform/lib/es6/random.js";

function handleKey(key_code, c_direction) {
  var switcher = key_code - 37 | 0;
  if (switcher > 3 || switcher < 0) {
    return undefined;
  } else {
    switch (switcher) {
      case 0 : 
          if (c_direction !== /* Left */3 && c_direction !== /* Right */1) {
            return /* Left */3;
          } else {
            return undefined;
          }
      case 1 : 
          if (c_direction !== /* Up */0 && c_direction !== /* Down */2) {
            return /* Up */0;
          } else {
            return undefined;
          }
      case 2 : 
          if (c_direction !== /* Right */1 && c_direction !== /* Left */3) {
            return /* Right */1;
          } else {
            return undefined;
          }
      case 3 : 
          if (c_direction !== /* Down */2 && c_direction !== /* Up */0) {
            return /* Down */2;
          } else {
            return undefined;
          }
      
    }
  }
}

function calcNextPos(n, param, param$1, param$2) {
  var y = param$1[1];
  var x = param$1[0];
  var max_y = param[1];
  var max_x = param[0];
  switch (param$2) {
    case 0 : 
        var new_y = y > 0 ? y - n | 0 : max_y;
        return /* tuple */[
                x,
                new_y
              ];
    case 1 : 
        var new_x = x < max_x ? x + n | 0 : 0;
        return /* tuple */[
                new_x,
                y
              ];
    case 2 : 
        var new_y$1 = y < max_y ? y + n | 0 : 0;
        return /* tuple */[
                x,
                new_y$1
              ];
    case 3 : 
        var new_x$1 = x > 0 ? x - n | 0 : max_x;
        return /* tuple */[
                new_x$1,
                y
              ];
    
  }
}

function updateBody(newMember, body) {
  var inner = function (m, l) {
    if (l) {
      return /* :: */[
              m,
              inner(l[0], l[1])
            ];
    } else if (m[2]) {
      return /* :: */[
              /* tuple */[
                m[0],
                m[1],
                false
              ],
              /* [] */0
            ];
    } else {
      return /* [] */0;
    }
  };
  return inner(newMember, body);
}

function spawnRandom(param, param$1, seed) {
  Random.init(seed);
  return /* tuple */[
          Random.$$int(param[1]) + param[0] | 0,
          Random.$$int(param$1[1]) + param$1[0] | 0
        ];
}

function spawnRandomSuper(param, param$1, seed) {
  Random.init(seed);
  return /* tuple */[
          Random.$$int(param[1]) + param[0] | 0,
          Random.$$int(param$1[1]) + param$1[0] | 0,
          List.nth(/* :: */[
                "x",
                /* :: */[
                  "o",
                  /* :: */[
                    ">",
                    /* [] */0
                  ]
                ]
              ], Random.$$int(3))
        ];
}

export {
  handleKey ,
  calcNextPos ,
  updateBody ,
  spawnRandom ,
  spawnRandomSuper ,
  
}
/* No side effect */

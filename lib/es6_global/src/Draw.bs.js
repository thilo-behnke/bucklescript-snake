// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE

import * as Actor from "./Actor.bs.js";
import * as Score from "./Score.bs.js";
import * as Utils from "./Utils.bs.js";
import * as Pervasives from "./../../../node_modules/bs-platform/lib/es6/pervasives.js";

function load_canvas(canvas_id) {
  var match = document.getElementById(canvas_id);
  if (match !== null) {
    return match;
  } else {
    console.log("cant find canvas " + (canvas_id + " \n"));
    return Pervasives.failwith("fail");
  }
}

function clear_canvas(canvas) {
  var context = canvas.getContext("2d");
  var cwidth = canvas.width;
  var cheight = canvas.height;
  context.clearRect(0, 0, cwidth, cheight);
  return /* () */0;
}

function draw_actor(canvas, snake, memberLength) {
  var context = canvas.getContext("2d");
  return Utils.MyList[/* forEachi */2]((function (param, i) {
                var match = param[0];
                var y = match[1];
                var x = match[0];
                var match$1;
                switch (param[1]) {
                  case 0 : 
                      match$1 = /* tuple */[
                        x,
                        y + memberLength | 0
                      ];
                      break;
                  case 1 : 
                      match$1 = /* tuple */[
                        x - memberLength | 0,
                        y
                      ];
                      break;
                  case 2 : 
                      match$1 = /* tuple */[
                        x,
                        y - memberLength | 0
                      ];
                      break;
                  case 3 : 
                      match$1 = /* tuple */[
                        x + memberLength | 0,
                        y
                      ];
                      break;
                  
                }
                var match$2 = i % 3;
                var color;
                if (match$2 > 2 || match$2 < 0) {
                  color = "#ffff00";
                } else {
                  switch (match$2) {
                    case 0 : 
                        color = "#ff0066";
                        break;
                    case 1 : 
                        color = "#0066ff";
                        break;
                    case 2 : 
                        color = "#00cc00";
                        break;
                    
                  }
                }
                var lineWidth = param[2] ? memberLength + 3 | 0 : memberLength;
                context.beginPath();
                context.strokeStyle = color;
                context.lineWidth = lineWidth;
                context.moveTo(match$1[0], match$1[1]);
                context.lineTo(x, y);
                context.stroke();
                return context.closePath();
              }), Actor.Snake[/* getData */7](snake));
}

function draw_prey(canvas, prey) {
  if (typeof prey === "number") {
    return /* () */0;
  } else {
    var match = prey[0][/* pos */0];
    var y = match[1];
    var x = match[0];
    var context = canvas.getContext("2d");
    var color;
    color = typeof prey === "number" ? "#ffff00" : (
        prey.tag ? "#ff0066" : "#000000"
      );
    context.beginPath();
    context.strokeStyle = color;
    context.lineWidth = 6;
    context.moveTo(x - 6 | 0, y);
    context.lineTo(x, y);
    context.stroke();
    return context.closePath();
  }
}

function draw_debug(canvas, game) {
  var context = canvas.getContext("2d");
  context.strokeStyle = "#ff0066";
  context.lineWidth = 3;
  context.rect(300, 0, 150, 100);
  context.stroke();
  var bodLength = Actor.Snake[/* length */4](game[/* snake */2]);
  var actorStr = "Body Length: " + String(bodLength);
  context.fillText(actorStr, 310, 10);
  var scoreStr = "Score: " + String(Score.Score[/* sum_score */1](game[/* eaten */1]));
  context.fillText(scoreStr, 310, 40);
  return /* () */0;
}

function draw_game(canvas, game, memberLength) {
  clear_canvas(canvas);
  draw_actor(canvas, game[/* snake */2], memberLength);
  draw_prey(canvas, game[/* spawn */3]);
  draw_debug(canvas, game);
  return /* () */0;
}

export {
  load_canvas ,
  clear_canvas ,
  draw_actor ,
  draw_prey ,
  draw_debug ,
  draw_game ,
  
}
/* No side effect */
